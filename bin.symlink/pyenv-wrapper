#!/usr/bin/env bash

# Globals
ARG_ALL=false               # ARG_ALL ? remote : local
ARG_DISTRIBUTION=false      # distribution filter specified ?
DISTRIBUTION=               # distribution filter
ARG_LATEST=false            # ARG_LATEST ? only latest : all
ARG_VERSION=false           # version filter specified ?
VERSION=                    # version filter

# Regexs used to parse PyEnv responses. E.g,
# pyenv install --list
# (stdout) \tDISTRIBUTION-VERSION
# Note CPython is represented by a blank distribution name. E.g,
#   3.7.0
#   miniconda3-4.3.30
RE_DISTRIBUTION="((.*)-)?"
RE_VERSION="([0-9]+\.[0-9]+\.[0-9]+)"
# groups: raw, _, distribution, version
RE_PYENV="s/^[ \t]*(${RE_DISTRIBUTION}${RE_VERSION})$"

# Console formatting
BOLD="$(tput bold)"; _BOLD="$(tput sgr0)"
UNDERLINE="$(tput smul)"; _UNDERLINE="$(tput rmul)"

function usage()
{
  SCRIPT_NAME="`basename ${BASH_SOURCE[0]}`"
  cat <<EOF
    usage: $SCRIPT_NAME [-a|--all] [-d|--distribution=<${UNDERLINE}distribution${_UNDERLINE}>]
                        [-h|--help] [-l|--latest]
                        [-v|--version=<${UNDERLINE}version${_UNDERLINE}>]
                        <command> [<args>]

    ${BOLD}OPTIONS${_BOLD}
        -a|--all
            Include remote results. Defaults filtering by results installed locally.
        -d|--distribution
            Filter results to specified ${UNDERLINE}distribution${_UNDERLINE}.
            Defaults to CPython.
        -h|--help
            Display this help information
        -l|--lastest
            Filter results to latest for specified distribution.
        -v|--version
            Semantic ${UNDERLINE}version${_UNDERLINE} template in form <major>.<minor>.<patch>.
            Supports wildcards, e.g. 3.1.* will filter to lastest 3.1 release.
            Defaults to wildcard filter "*.*.*"

    ${BOLD}COMMANDS${_BOLD}

    List information about available Python versions
        ver|versions                Available versions
        dist|distributions          Availble distributions

    Python installation
        install                     Install Python version

    Meta
        help                        Display this help information

EOF
}

# Identity function that returns 1 if passed an empty list
# Arguments: 
#   stdin: _
# Returns:
#   stdout: _
#   1: Empty list
function error_if_empty()
{
    awk '{ print } END { if (NR == 0) { exit 1 }}' < /dev/stdin
}

# Identity function
# Arguments:
#   stdin: _
# Returns:
#   stdout: _
function identity()
{
    cat < /dev/stdin
}

# Filters PyEnv versions list by distribution
# Arguments:
#   stdin: \tDISTRIBUTION-VERSION
# Globals:
#   DISTRIBUTION
# Returns:
#   stdout: versions (asc)
function filter_by_distribution()
{
    # groups: raw, distribution, version
    sed -nr "${RE_PYENV}/\1,\3,\4/p" \
        | awk -F"," -v x="$DISTRIBUTION" '$2==x {print $3}' \
        | sort -V \
        < /dev/stdin
}

# Filters PyEnv versions list to get unique list of distributions
# Arguments:
#   stdin: \tDISTRIBUTION-VERSION
# Returns:
#   stdout: distributions (asc)
function extract_distributions()
{
    # groups: distribution
    # cpython defaults to blank distribution name so fix that up
    sed -nr "${RE_PYENV}/\3/p" \
        | sed 's/^$/cpython/' \
        | sort \
        | uniq \
        < /dev/stdin
}

# Filters PyEnv versions list by version specification
# Arguments:
#   stdin: \tDISTRIBUTION-VERSION
# Globals:
#   VERSION
# Returns:
#   stdout: versions (asc)
function filter_by_version()
{
    local version_pattern
    local -a version_parts

    # replace * with [[:digit:]] ( * needs escaping to prevent globbing )
    version_pattern="${VERSION//\*/[[:digit:]]}"

    # split version into parts array on IFS
    version_parts=( ${version_pattern//./ } )

    # -o: only display matched text (i.e. the version)
    grep -o "${version_parts[0]}.${version_parts[1]}.${version_parts[2]}" \
        | sort -V \
        < /dev/stdin
}

# Lists all Python versions available, defaulting to CPython
# Globals:
#   ARG_ALL
#   ARG_LATEST
#   DISTRIBUTION
# Returns:
#   stdout: versions (asc)
#   1: no versions available
function CMD_versions()
{
    echo "Listing $TXT_LATEST of $TXT_DIST distribution $TXT_FROM" \
        "`$ARG_VERSION && echo "matching version specification $TXT_VERSION"`" \
        >&2

    ( $ARG_ALL && pyenv install --list || pyenv versions ) \
        | filter_by_distribution \
        | ( $ARG_VERSION && filter_by_version || identity ) \
        | ( $ARG_LATEST && tail -n 1 || identity ) \
        | error_if_empty

    if ! (( $? == 0 )); then
        echo "No versions of $TXT_DIST distribution $TXT_FROM" >&2; false
    fi
}

# Lists all Python distributions available
# Globals:
#   ARG_ALL
# Returns:
#   stdout: distributions (asc)
#   1: no distributions available
function CMD_distributions()
{
    echo "Listing distributions $TXT_FROM" >&2

    ( $ARG_ALL && pyenv install --list || pyenv versions ) \
        | extract_distributions \
        | error_if_empty

    if ! (( $? == 0 )); then
        echo "No distributions $TXT_FROM" >&2; false
    fi
}

# Installs specified Python version
# Globals:
#   ARG_VERSION
#   ARG_DISTRIBUTION
# Returns:
#   1: no matching Python version available
function CMD_install()
{
    local version

    echo "Determining latest version of $TXT_DIST" \
        "`$ARG_VERSION && echo "matching version spec $TXT_VERSION"`" >&2

    if ! version="`pyenv install --list \
        | filter_by_distribution \
        | ( $ARG_VERSION && filter_by_version || identity ) \
        | tail -n 1 \
        | error_if_empty`"; then
        echo "No versions of $TXT_DIST distribution available to install" >&2
        false; return
    fi

    echo "Installing ${BOLD}${version}${_BOLD} of $TXT_DIST" >&2

    if ! pyenv install "$version" >&2; then
        echo "ERROR: Installation of $version of $TXT_DIST failed" >&2
        false; return
    fi
}

# -o short options, --long long options
# -q manual error handling
# opt --> flag, opt: --> option with mandatory arg, opt:: --> option with optional arg
if ! OPTS=`getopt -q -o ad:lv: --long all,distribution:,latest,version: -- "$@"`; then
    usage ; exit
fi

eval set -- "$OPTS"

while true ; do
    case "$1" in
        -a|--all) ARG_ALL=true ; shift ;;
        -d|--distribution)
            case "$2" in                
                *) ARG_DISTRIBUTION=true ; DISTRIBUTION="$2" ; shift 2 ;;
            esac ;;
        -h|--help) usage ; exit ;;
        -l|--latest) ARG_LATEST=true; shift ;;
        -v|--version)
            case "$2" in
                [0-9\*].[0-9\*].[0-9\*])
                    ARG_VERSION=true ; VERSION="$2" ; shift 2 ;;
                *) usage ; exit 1 ;;
            esac ;;
        --) shift ; break ;;
        *) usage ; exit 1 ;;
    esac
done

if ! (( $# == 1 )); then
    usage ; exit
fi

COMMAND="$1" ; shift

# Strings used by CLI stdout
$ARG_LATEST && TXT_LATEST="${BOLD}latest version${_BOLD}" \
    || TXT_LATEST="${BOLD}all versions${_BOLD}"
$ARG_DISTRIBUTION && TXT_DIST="${BOLD}${DISTRIBUTION}${_BOLD}" \
    || TXT_DIST="${BOLD}CPython${_BOLD}"
$ARG_ALL && TXT_FROM="${BOLD}available remotely${_BOLD}" \
    || TXT_FROM="${BOLD}installed locally${_BOLD}"
$ARG_VERSION && TXT_VERSION="${BOLD}${VERSION}${_BOLD}" \
    || TXT_VERSION="${BOLD}*.*.*${_BOLD}"

case "$COMMAND" in
    ver|versions) CMD_versions ;;
    dist|distributions) CMD_distributions ;;
    install) CMD_install ;;
    help) usage ; exit ;;
    *) usage ; exit 1 ;;
esac
